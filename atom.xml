<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>突然冷风吹</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hellolife.top/"/>
  <updated>2018-08-06T08:29:42.916Z</updated>
  <id>http://hellolife.top/</id>
  
  <author>
    <name>yuangy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mnesia数据库</title>
    <link href="http://hellolife.top/13754dc.html"/>
    <id>http://hellolife.top/13754dc.html</id>
    <published>2018-08-06T08:49:22.139Z</published>
    <updated>2018-08-06T08:29:42.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mnesia数据库（内存，磁盘）"><a href="#Mnesia数据库（内存，磁盘）" class="headerlink" title="Mnesia数据库（内存，磁盘）"></a>Mnesia数据库（内存，磁盘）</h2><h2 id="创建-删除-数据库"><a href="#创建-删除-数据库" class="headerlink" title="创建/删除 数据库"></a>创建/删除 数据库</h2><ul><li><p>创建/删除一个本地数据库：</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mnesia:create_schema([node()]). </span><br><span class="line">mnesia:delete_schema([node()]).</span><br></pre></td></tr></table></figure></li><li><p>启动erlang时指定一个特定的数据库</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ erl -mnesia dir '<span class="string">"/home/Mnesia.company"</span>' <span class="comment">%% /home/Mnesia.company是将要保存这个数据库的目录</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><hr><h2 id="开启-关闭-数据库"><a href="#开启-关闭-数据库" class="headerlink" title="开启/关闭 数据库"></a>开启/关闭 数据库</h2><ul><li><strong>其中mnesia:wait_for_tables/2的作用</strong>：一些应用的某些表可能由于表数据很大，以至初始的适合需要一个初始等待的时间才能正常访问到该表的数据。mnesia:wait_for_tables/2 悬停等待一段时间，直到在 TabList 的所有表可以被访问，或超过等待的时间。<figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">start</span><span class="params">()</span> -&gt;</span>  mnesia:start(),mnesia:wait_for_tables([shop,cost],<span class="number">2000</span>).</span><br><span class="line"><span class="function"><span class="title">stop</span><span class="params">()</span> -&gt;</span>  mnesia:stop().</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% create_table（Name，TabDef） - &gt; &#123;atomic，ok&#125; | &#123;aborted，Reason&#125;</span></span><br><span class="line">mnesia:create_table(table_name,[&#123;attributes,record_info(fields,shop)&#125;])</span><br><span class="line"><span class="comment">%% 下面这个是官方示例</span></span><br><span class="line">mnesia:create_table(mnesia_table_name, [&#123;ram_copies, [node()]&#125;, &#123;disc_only_copies, nodes()&#125;, &#123;storage_properties, [&#123;ets, [compressed]&#125;, &#123;dets, [&#123;auto_save, <span class="number">5000</span>&#125;]&#125; ]&#125;]).</span><br></pre></td></tr></table></figure><ul><li>record_info(type,record_name)：读取记录信息。type可为<code>fields</code>和<code>size</code>，分别为字段信息和长度信息。<figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-record</span><span class="params">(shop,&#123;item, quantity, cost&#125;)</span>.</span><br><span class="line"><span class="function"><span class="title">test_record_info</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    [record_info(fields,shop),record_info(size,shop)].</span><br><span class="line">调用test_record_info()输出：</span><br><span class="line"> [[item,quantity,cost],<span class="number">4</span>] <span class="comment">%% 字段三个，长度为4</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>Name:表名</li><li>TabDef:列表，列表元素为{key，value}的元组，允许的元组有：</li></ol><table><thead><tr><th>元组</th><th>默认值</th><th>可设值</th><th>说明</th></tr></thead><tbody><tr><td>{access_mode，Atom}</td><td>read_write</td><td>read_write/read_only</td><td>访问模式：读写模式，只读模式</td></tr><tr><td>{attributes，AtomList}</td><td>[key，val]</td><td></td><td>设置表的字段</td></tr><tr><td>{disc_copies，Nodelist}</td><td></td><td></td><td>NodeList是一个Erlang的节点列表，这些节点将保存表的==磁盘副本==，同时==执行这个操作的节点==上还会创建一个的表的==内存副本==。</td></tr><tr><td>{disc_only_copies，Nodelist}</td><td></td><td></td><td>NodeList是一个Erlang的节点列表，这些节点将==只==保存表的==磁盘副本==</td></tr><tr><td>{ram_copies，Nodelist}</td><td></td><td></td><td>NodeList是一个Erlang的节点列表，这些节点将保存表的==内存副本==</td></tr><tr><td>{index，Intlist}</td><td></td><td></td><td>Mnesia要构建和维护额外索引表的属性名称（原子）或记录字段的列表</td></tr><tr><td>{load_order，Integer}</td><td>0</td><td></td><td>具有最高加载顺序优先级的表在启动时首先加载。</td></tr><tr><td>{majority，Flag}</td><td></td><td>true/false</td><td>为true，非脏更新中止</td></tr><tr><td>{record_name，Name}</td><td></td><td></td><td></td></tr><tr><td>{snmp，SnmpStruct}</td><td></td><td></td><td></td></tr><tr><td>{storage_properties，[{Backend，Properties}]}</td><td></td><td></td><td></td></tr><tr><td>{type，Type}</td><td>set</td><td>set/ordered_set/bag/duplicate_bag</td><td>表类型</td></tr><tr><td>{local_content，Bool}</td><td>false</td><td>true/false</td><td></td></tr></tbody></table><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><ul><li><p>构建查询的基本代码,即QLC查询，参数是一个列表推导，所以查询时，当然可以进行条件筛选查询甚至连接查询！</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q = qlc:q([X || X &lt;- mnesia:table(Table_Name)])</span><br></pre></td></tr></table></figure></li><li><p>执行QLC查询,将查询到结果以列表形式返回</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qlc:e(Q)</span><br></pre></td></tr></table></figure></li><li><p>我们将qlc:e(Q)封装一下，在Mnesia事务内调用，使它变得“更为好用”。</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">do</span><span class="params">(Q)</span> -&gt;</span></span><br><span class="line">    F = <span class="keyword">fun</span>() -&gt; qlc:e(Q) <span class="keyword">end</span>,</span><br><span class="line">    &#123;atomic,Val&#125; = mnesia:transaction(F),</span><br><span class="line">    Val.</span><br></pre></td></tr></table></figure></li><li><p><font color="red">注意：</font>qlc:q/1的参数必须是一个字面上的列表推倒，不能是通过求值得出的。举个例子，下面的代码与示例里的代码不是等价的。</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Var = [X || X &lt;- mnesia:table(shop)],</span><br><span class="line">qlc:q(Var)</span><br></pre></td></tr></table></figure></li></ul><h2 id="添加行"><a href="#添加行" class="headerlink" title="添加行"></a>添加行</h2><ul><li>下面是添加一行的记录示例，Row是待插入的记录。也是以在Mnesia事务内调用mnesia:write/1函数。<figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_shop_item</span><span class="params">(Name, Quantity, Cost)</span> -&gt;</span></span><br><span class="line">    Row = #shop&#123;item=Name, quantity=Quantity, cost=Cost&#125;,</span><br><span class="line">    F = <span class="keyword">fun</span>() -&gt; mnesia:write(Row) <span class="keyword">end</span>,</span><br><span class="line">    mnesia:transaction(F).</span><br></pre></td></tr></table></figure></li></ul><h2 id="移除行"><a href="#移除行" class="headerlink" title="移除行"></a>移除行</h2><ul><li>要移除某一行，需要知道该行的对象ID。它由表名和主键的值构成。下面是删除一行的记录示例。仍然是以Mnesia事务内调用mnesia:delete/1函数。<figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">remove_shop_item</span><span class="params">(Item)</span> -&gt;</span></span><br><span class="line">    Oid = &#123;shop,Item&#125;,</span><br><span class="line">    F = <span class="keyword">fun</span>() -&gt; mnesia:delete(Oid) <span class="keyword">end</span>,</span><br><span class="line">    mnesia:transaction(F).</span><br></pre></td></tr></table></figure></li></ul><h2 id="Mnesia中的事务：采用悲观锁策略"><a href="#Mnesia中的事务：采用悲观锁策略" class="headerlink" title="Mnesia中的事务：采用悲观锁策略"></a>Mnesia中的事务：采用悲观锁策略</h2><ul><li><strong>悲观锁</strong>：每当Mnesia事务管理器==开始访问==一个表时，==都==会根据上下文情况尝试==锁定==记录甚至整个表。如果它发现这可能导致死锁，就会立即中止事务并撤销之前所做的改动。</li><li>乐观锁：提交更新的时候，才会对数据锁定并检测，如果发现冲突了，则让用户返回错误的信息，让用户决定如何去做。</li><li>F是一个不带参数的fun，事务的特性是：F里的读写操作要么都成功，要么都不成功。<figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">do_someting</span><span class="params">(...)</span> -&gt;</span></span><br><span class="line">    F = <span class="keyword">fun</span>() -&gt;</span><br><span class="line">        mnesia:write(Row),</span><br><span class="line">        mnesia:delete(Oid),</span><br><span class="line">        qlc:e(Q)</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">mnesia:transaction(F)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mnesia数据库（内存，磁盘）&quot;&gt;&lt;a href=&quot;#Mnesia数据库（内存，磁盘）&quot; class=&quot;headerlink&quot; title=&quot;Mnesia数据库（内存，磁盘）&quot;&gt;&lt;/a&gt;Mnesia数据库（内存，磁盘）&lt;/h2&gt;&lt;h2 id=&quot;创建-删除-数据库&quot;&gt;&lt;a href=&quot;#创建-删除-数据库&quot; class=&quot;headerlink&quot; title=&quot;创建/删除 数据库&quot;&gt;&lt;/a&gt;创建/删除 数据库&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建/删除一个本地数据库：&lt;/p&gt;
&lt;figure class=&quot;highlight erl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mnesia:create_schema([node()]). &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mnesia:delete_schema([node()]).&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动erlang时指定一个特定的数据库&lt;/p&gt;
&lt;figure class=&quot;highlight erl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ erl -mnesia dir &#39;&lt;span class=&quot;string&quot;&gt;&quot;/home/Mnesia.company&quot;&lt;/span&gt;&#39; &lt;span class=&quot;comment&quot;&gt;%% /home/Mnesia.company是将要保存这个数据库的目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://hellolife.top/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://hellolife.top/tags/Erlang/"/>
    
      <category term="Mnesia" scheme="http://hellolife.top/tags/Mnesia/"/>
    
  </entry>
  
  <entry>
    <title>Erlang基础</title>
    <link href="http://hellolife.top/3380.html"/>
    <id>http://hellolife.top/3380.html</id>
    <published>2018-08-02T01:13:28.084Z</published>
    <updated>2018-08-02T10:23:14.644Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>Erlang：函数式编程，消息传递，容错，高并发。</strong><br><a id="more"></a></p><hr><h3 id="语句和注释"><a href="#语句和注释" class="headerlink" title="语句和注释"></a>语句和注释</h3><ol><li>“ . ”作为一条语句结束（参考英语句子）</li><li>“ ; ”连接的语句表示“或”，“ , ”连接的语句表示“且” (参考when关卡)</li><li>“%”来做行注释<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1&gt;</span> F = fun(A,B) when is_number(A),is_number(B) -&gt; A+B end. </span><br><span class="line"><span class="meta">#</span>Fun&lt;erl_eval.12.52032458&gt;</span><br><span class="line"><span class="meta">2&gt;</span> F(3,4).  </span><br><span class="line">7</span><br><span class="line"><span class="meta">3&gt;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ol><li><strong>number：</strong>erlang中的整数是精确到，也就是说不像其他编程语言（java）中有short，int，long的说法。</li><li><strong>浮点数：</strong>erlang在内部使用64位的<em>IEEE754-1985</em>，因此也会存在像C中的取整和精度问题。</li><li><strong>原子：</strong>原子被用来表示常量值（类似java中的枚举），<code>原子是全局性的，而且不需要宏定义或包含文件就能实现，原子以小写字母开头，后接一串字母、数字、下划线、@符号，原子还可以放在单引号&#39;&#39;内，这样定义原子的规则便没那么严格了，例如&#39;Monday&#39;、&#39;+&#39;,另外，原子的值就是原子本身。</code></li><li><strong>元组：</strong>大括号包起来，里面用逗号隔开的一种erlang数据类型，通常元组第一位用一个语义化的原子值占位。</li><li><strong>列表：</strong>被用来存放任意数据类型任意数量的数据类型，类似js中的数组。</li><li><strong>字符串：</strong>双引号包起来，严格来说，erlang中没有字符串，其本质就是列表。所以一般如果你想用真·字符串的时候，用Erlang的Binary类型，这样表示：&lt;&lt;”abc”&gt;&gt;。</li><li><strong>二进制型与位串：</strong>在二进制里使用整数时，必须属于0~255这个范围。二进制型&lt;&lt;”cat”&gt;&gt;是&lt;&lt;99,97,116&gt;&gt;的简写形式，也就是说，这个二进制型是由字符串里这些字符的ASCII编码组成的。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1&gt;</span> 1. %% 整数</span><br><span class="line">1</span><br><span class="line"><span class="meta">2&gt;</span> 1.2 . %% 浮点数</span><br><span class="line">1.2</span><br><span class="line"><span class="meta">3&gt;</span> a. %% 原子</span><br><span class="line">a</span><br><span class="line"><span class="meta">4&gt;</span> &#123;point,1,2&#125;. %% 元组</span><br><span class="line">&#123;point,1,2&#125;</span><br><span class="line"><span class="meta">5&gt;</span> [1,2,3]. %% 列表</span><br><span class="line">[1,2,3]</span><br><span class="line"><span class="meta">6&gt;</span> "1,2,3". %% 字符串</span><br><span class="line">"1,2,3"</span><br><span class="line"><span class="meta">7&gt;</span> &lt;&lt;"cat"&gt;&gt;. %% 二进制与位串</span><br><span class="line">&lt;&lt;"cat"&gt;&gt;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="变量与模式匹配"><a href="#变量与模式匹配" class="headerlink" title="变量与模式匹配"></a>变量与模式匹配</h3><p>erlang中<code>不存在赋值</code>的概念，只有<code>变量绑定值</code>，而且一次绑定不可改变，即“一次性赋值”。变量必须首字母大写。变量与值绑定用“=”表示，称为一次模式匹配操作。<br><strong>模式匹配的一些例子：</strong></p><table><thead><tr><th>模式 = 单位</th><th style="text-align:left">结果</th></tr></thead><tbody><tr><td> {X,abc} = {123,abc}</td><td style="text-align:left">成功:X=123 </td></tr><tr><td> {X,Y,Z} = {222,def,”cat”}</td><td style="text-align:left">成功：X = 222,Y = def, Z = “cat”</td></tr><tr><td> {X,Y} = {222,def,”cat”}</td><td style="text-align:left">失败：元组的形状不同</td></tr><tr><td> X = true</td><td style="text-align:left">成功：X = true</td></tr><tr><td> [H&#124;T] = [1,2,3,4,5]</td><td style="text-align:left">成功: H = 1,T = [2,3,4,5]</td></tr><tr><td> [A,B,C&#124;T] = [a,b,c,d,e,f]</td><td style="text-align:left">成功：A=a,B=b,C=c,T=[d,e,f]</td></tr></tbody></table><hr><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><ol><li>模块是Erlang的基本代码单元，模块保存在扩展名为<code>.erl</code>的文件里,而且必须先编译，才能运行模块里的代码。编译后的模块以<code>.beam</code>作为扩展名<center>待续</center></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;strong&gt;Erlang：函数式编程，消息传递，容错，高并发。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://hellolife.top/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://hellolife.top/tags/Erlang/"/>
    
      <category term="函数式编程" scheme="http://hellolife.top/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
