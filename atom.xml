<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>突然冷风吹</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hellolife.top/"/>
  <updated>2018-08-06T10:07:57.205Z</updated>
  <id>http://hellolife.top/</id>
  
  <author>
    <name>yuangy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Erlang并发编程（一）</title>
    <link href="http://hellolife.top/e06690c7.html"/>
    <id>http://hellolife.top/e06690c7.html</id>
    <published>2018-08-06T10:05:16.262Z</published>
    <updated>2018-08-06T10:07:57.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><ul><li>两种创建进程方式，Pid：进程标识符，self()：当前进程Pid<figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pid = spawn(Mod,Func,Args) <span class="comment">%% MFA,支持动态代码升级</span></span><br><span class="line">Pid = spawn(Fun) <span class="comment">%% Fun</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="发消息"><a href="#发消息" class="headerlink" title="发消息"></a>发消息</h2><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pid ! Message</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="收消息"><a href="#收消息" class="headerlink" title="收消息"></a>收消息</h2><ul><li>进程中的几个概念：<strong>定时器，邮箱队列，保存队列</strong><ol><li><strong>定时器</strong>：如果receive体包含arter超时部分，那么进入receiv会启动一个定时器。</li><li><strong>邮箱队列</strong>：每个进程都有一个邮箱队列，接收到的消息首先会存放在邮箱队列中，提供给receive进行匹配。</li><li><strong>保存队列</strong>：保存邮箱队列中没有匹配上的消息。</li></ol></li><li>receive的工作方式：<ol><li>进入receive时，启动定时器</li><li>逐个取出邮箱队列中的消息与receive中的Pattern逐个进行匹配，匹配上直接移除该条消息，匹配不上，放进保存队列</li><li>如果邮箱队列里的消息都不匹配，进程就会被挂起并重新调度，直到新消息进入邮箱才会继续执行。<strong>注意：保存队列的消息不会重新匹配。</strong></li><li>没有定时器时，匹配成功，保存队列里的消息会按照到达进程的顺序重新进入邮箱，如果有定时器，就会清楚保存队列里的消息</li><li>定时器到期，系统会将保存队列里的消息重新放回邮箱队列。</li></ol></li></ul><hr><ul><li><p>基本的接收消息方式</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">receive</span></span><br><span class="line">    Pattern1 [关卡] -&gt; </span><br><span class="line">        do...;</span><br><span class="line">    Pattern2 [关卡] -&gt;</span><br><span class="line">        do...;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>带超时的接收<br>如果超时为0，系统会在进入after之前对邮箱队列里的消息进行匹配，然后执行超时后的处理。</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">receive</span></span><br><span class="line">    Pattern1 [关卡] -&gt; </span><br><span class="line">        do...;</span><br><span class="line">    Pattern2 [关卡] -&gt;</span><br><span class="line">        do...;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">after</span> Time -&gt;</span><br><span class="line">    do...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>只带超时的接收</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">receive</span></span><br><span class="line"><span class="keyword">after</span> Time -&gt;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="注册进程"><a href="#注册进程" class="headerlink" title="注册进程"></a>注册进程</h2><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">register</span><span class="params">(Atom_Process_Name,Pid)</span></span></span><br><span class="line"><span class="function"><span class="title">unregister</span><span class="params">(Atom_Process_Name)</span></span></span><br><span class="line"><span class="function"><span class="title">whereis</span><span class="params">(Atom_Process_Name)</span> -&gt;</span> Pid | undefined <span class="comment">%% 检查Atom_Process_Name是否已被注册</span></span><br><span class="line">registed() [Atom_Process_Name::atom()] <span class="comment">%% 返回注册列表</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建进程&quot;&gt;&lt;a href=&quot;#创建进程&quot; class=&quot;headerlink&quot; title=&quot;创建进程&quot;&gt;&lt;/a&gt;创建进程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;两种创建进程方式，Pid：进程标识符，self()：当前进程Pid&lt;figure class=&quot;highlight erl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Pid = spawn(Mod,Func,Args) &lt;span class=&quot;comment&quot;&gt;%% MFA,支持动态代码升级&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Pid = spawn(Fun) &lt;span class=&quot;comment&quot;&gt;%% Fun&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;发消息&quot;&gt;&lt;a href=&quot;#发消息&quot; class=&quot;headerlink&quot; title=&quot;发消息&quot;&gt;&lt;/a&gt;发消息&lt;/h2&gt;&lt;figure class=&quot;highlight erl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Pid ! Message&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://hellolife.top/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://hellolife.top/tags/Erlang/"/>
    
      <category term="并发编程" scheme="http://hellolife.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Erlang并发编程（二）</title>
    <link href="http://hellolife.top/d0707c1f.html"/>
    <id>http://hellolife.top/d0707c1f.html</id>
    <published>2018-08-06T10:05:16.262Z</published>
    <updated>2018-08-06T10:08:14.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Erlang进程中的一些概念"><a href="#Erlang进程中的一些概念" class="headerlink" title="Erlang进程中的一些概念"></a>Erlang进程中的一些概念</h2><a id="more"></a><ol><li>进程<ol><li>普通进程：spawn创建的进程是普通进程。</li><li>系统进程：普通进程可执行<code>process_flag(trap_exit,true)</code>变成系统进程。</li></ol></li><li><p>进程可以<strong>相互</strong>连接。如果进程A和B两个进程有连接，而A出于某种原因终止了，就会向B发送一个错误信号，反之亦然。当A或B收到连接进程发送的错误信号时，随之自己也会挂掉，同时发送错误信号给与他连接的其他进程，即会产生“连锁反应”，凡是连接的普通进程都会挂掉。==但，这种“连锁反应”会在遇到系统进程时终止，系统进程相当于防火墙。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">link(Pid) %% 当前进程与 Pid 进程连接</span><br><span class="line">unlink(Pid) %% 当前进程与 Pid 进程解除连接</span><br><span class="line">spawn_link(Fun) -&gt; Pid %% 分裂一个新的进程，同时，当前进程同新进程建立连接</span><br><span class="line">spawn_link(Mod,Func,Args) -&gt; Pid %% 同上</span><br></pre></td></tr></table></figure></li><li><p>监视，类似连接，但它是单向的。如果A监视B，而B出于某种原因终止了，就会向A发送一个宕机的消息，反过来不行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spawn_monitor(Fun) -&gt; &#123;Pid,Ref&#125;  %% 当前进程分裂一个进程，并监视该进程，Pid是新进程的进程标识，Ref是该进程的引用，如果这个进程因为Why的原因终止了，消息&#123;&apos;DOWN&apos;,Ref,process,Pid,Why&#125;就会被发往父进程</span><br><span class="line">spawn_monitor(Mod,Func,Args) -&gt; &#123;Pid,Ref&#125; %% 同上</span><br><span class="line">erlang:monitor(process,Item) -&gt;Ref %% 执行改函数的进程监视Item代表的进程，Item是Pid或者进程注册名称</span><br><span class="line">demonitor(Ref) -&gt; true %% 它会移除以Ref作为引用的监视</span><br></pre></td></tr></table></figure></li><li><p>消息和错误信号</p><ol><li>消息是进程间的“正常交流”，需要主动发送。</li><li>错误信号是进程崩溃或进程终止时自动发送的。错误信号会发送给终止进程的连接组。</li></ol></li><li><p>系统进程收到错误信号时，该信号会被转换成{‘EXIT’,Pid,Why}。</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">exit</span><span class="params">(Why)</span> %%当前进程退出</span></span><br><span class="line"><span class="function"><span class="title">exit</span><span class="params">(Pid,Why)</span> %%P<span class="title">id</span>进程退出，执行改函数的进程不会退出</span></span><br></pre></td></tr></table></figure></li><li><p>杀死进程</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">exit</span><span class="params">(Pid,kill)</span> %%杀死进程</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Erlang进程中的一些概念&quot;&gt;&lt;a href=&quot;#Erlang进程中的一些概念&quot; class=&quot;headerlink&quot; title=&quot;Erlang进程中的一些概念&quot;&gt;&lt;/a&gt;Erlang进程中的一些概念&lt;/h2&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://hellolife.top/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://hellolife.top/tags/Erlang/"/>
    
      <category term="并发编程" scheme="http://hellolife.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Erlang-gen_server</title>
    <link href="http://hellolife.top/1593793e.html"/>
    <id>http://hellolife.top/1593793e.html</id>
    <published>2018-08-06T09:47:52.891Z</published>
    <updated>2018-08-06T09:57:07.564Z</updated>
    
    <content type="html"><![CDATA[<h3 id="start-link"><a href="#start-link" class="headerlink" title="start_link"></a>start_link</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start_link() -&gt;</span><br><span class="line">    gen_server:start_link(&#123;local, ch3&#125;, ch3, [], []) =&gt; &#123;ok, Pid&#125;</span><br></pre></td></tr></table></figure><p><strong>调用</strong>gen_server:start_link/4，创建并且注册一个新进程</p><ul><li>第一个参数：local表示在本地注册，用模块名ch3作为进程注册的名称</li><li>第二个参数：回调模块的名字，因为gen_server的接口函数和回调函数是在同一个模块里面，所以   这里也为ch3</li><li>第三个参数：[]这个为gen_server:start_link内部调用init（回调函数）时，给init传递的参数</li><li>第四个参数：[]是参数的列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Options ::= [&#123;timeout, Timeout&#125; | &#123;debug, [Flag]&#125;]</span><br><span class="line">%%%      Flag ::= trace | log | &#123;logfile, File&#125; | statistics | debug</span><br><span class="line">%%%     (debug == log &amp;&amp; statistics)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><hr><h3 id="同步调用–call"><a href="#同步调用–call" class="headerlink" title="同步调用–call"></a>同步调用–call</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">do_some() -&gt;</span><br><span class="line">  gen_server:call(ch3, alloc).</span><br></pre></td></tr></table></figure><ul><li>第一个参数：ch3是注册的gen_server进程名字</li><li>第二个参数：是具体传递的参数，为term()，即erlang数据类型</li><li>第三个参数：超时时间int</li></ul><p><strong>请求</strong>以消息的形式发给gen_server进程ch3，当gen_server进程收到消息后回调handle_call(Request, From, State),它应返回一个元组 {reply, Reply, State1}。Reply是需要回馈给客户端的答复，同时 State1 是gen_server的状态的新值。</p><hr><h3 id="异步请求——Cast"><a href="#异步请求——Cast" class="headerlink" title="异步请求——Cast"></a>异步请求——Cast</h3><p>异步请求 free(ch) 使用 gen_server:cast/2 实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(Ch) -&gt;</span><br><span class="line">    gen_server:cast(ch3, &#123;free, Chr&#125;).</span><br></pre></td></tr></table></figure></p><p>ch3 是gen_server的名称。 {free, Ch} 是实际的请求。</p><p>请求被装在一个消息中发给gen_server的 cast ，这调用了 free ，然后返回了 ok 。</p><p>当gen_server收到请求之后，它会调用 handle_cast(Request, Stats) ，会返回一个元组 {noreply, State1} 。 State1 是gen_server状态的新值。</p><p>handle_cast({free, Ch}, Chs) -&gt;<br>    Chs2 = free(Ch, Chs),<br>    {noreply, Chs2}.<br>在这里，新的状态便是更新过的可用频道列表 Chs2 。gen_server现在又可以接受新的请求了。</p><hr><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><p>在==监督树中==<br>若gen_server是某个监督树的一部分，则无需停止函数。它的督程会自动终止它。它的具体做法由督程中设置的 关闭策略 定义。</p><p>如果在终止之前需要进行一些清理工作，那么关闭策略必须是一个超时值，同时gen_server必须在 init 函数中设置为捕获退出信号。当gen_server被要求关闭时，它就会调用回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">terminate(shutdown, State) ：</span><br><span class="line"></span><br><span class="line">init(Args) -&gt;</span><br><span class="line">    ...,</span><br><span class="line">    process_flag(trap_exit, true),</span><br><span class="line">    ...,</span><br><span class="line">    &#123;ok, State&#125;.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">terminate(shutdown, State) -&gt;</span><br><span class="line">    ..code for cleaning up here..</span><br><span class="line">    ok.</span><br></pre></td></tr></table></figure></p><h3 id="独立Gen-Server"><a href="#独立Gen-Server" class="headerlink" title="独立Gen_Server"></a>独立Gen_Server</h3><p>如果gen_server并非某个监督树的一部分，那么可以用一个停止函数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">export([stop/0]).</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">stop() -&gt;</span><br><span class="line">    gen_server:cast(ch3, stop).</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">handle_cast(stop, State) -&gt;</span><br><span class="line">    &#123;stop, normal, State&#125;;</span><br><span class="line">handle_cast(&#123;free, Ch&#125;, State) -&gt;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">terminate(normal, State) -&gt;</span><br><span class="line">    ok.</span><br></pre></td></tr></table></figure><p>回调函数处理 stop 请求并返回一个元组 {stop, normal, State1} ，其中 normal 表示这是一个正常的终止， State1 是gen_server状态的新值。这会引发gen_server调用 terminate(normal, State1) 来优雅地终止。</p><h3 id="处理其他消息"><a href="#处理其他消息" class="headerlink" title="处理其他消息"></a>处理其他消息</h3><p>如果要想gen_server还能处理请求之外的消息，必须实现回调函数 handle_info(Info, State) 来处理他们。例如，如果gen_server联结到其它进程（非督程）上并捕获退出信号，那么其它的消息就有退出消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handle_info(&#123;&apos;EXIT&apos;, Pid, Reason&#125;, State) -&gt;</span><br><span class="line">    ..code to handle exits here..</span><br><span class="line">    &#123;noreply, State1&#125;.</span><br></pre></td></tr></table></figure><blockquote><p>参考链接：<br><a href="https://cloud.tencent.com/developer/section/1122601" target="_blank" rel="noopener">[1] 腾讯云开发者手册</a><br><a href="http://www.cnerlang.com/lib/stdlib-3.1/doc/html/index.html" target="_blank" rel="noopener">[2] Erlang在线手册</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;start-link&quot;&gt;&lt;a href=&quot;#start-link&quot; class=&quot;headerlink&quot; title=&quot;start_link&quot;&gt;&lt;/a&gt;start_link&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;start_link() -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    gen_server:start_link(&amp;#123;local, ch3&amp;#125;, ch3, [], []) =&amp;gt; &amp;#123;ok, Pid&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;调用&lt;/strong&gt;gen_server:start_link/4，创建并且注册一个新进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数：local表示在本地注册，用模块名ch3作为进程注册的名称&lt;/li&gt;
&lt;li&gt;第二个参数：回调模块的名字，因为gen_server的接口函数和回调函数是在同一个模块里面，所以   这里也为ch3&lt;/li&gt;
&lt;li&gt;第三个参数：[]这个为gen_server:start_link内部调用init（回调函数）时，给init传递的参数&lt;/li&gt;
&lt;li&gt;第四个参数：[]是参数的列表&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Options ::= [&amp;#123;timeout, Timeout&amp;#125; | &amp;#123;debug, [Flag]&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%%%      Flag ::= trace | log | &amp;#123;logfile, File&amp;#125; | statistics | debug&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%%%     (debug == log &amp;amp;&amp;amp; statistics)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://hellolife.top/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://hellolife.top/tags/Erlang/"/>
    
      <category term="Gen_server" scheme="http://hellolife.top/tags/Gen-server/"/>
    
      <category term="OTP" scheme="http://hellolife.top/tags/OTP/"/>
    
  </entry>
  
  <entry>
    <title>Erlang-ETS存储数据</title>
    <link href="http://hellolife.top/9e399184.html"/>
    <id>http://hellolife.top/9e399184.html</id>
    <published>2018-08-06T09:08:08.447Z</published>
    <updated>2018-08-06T09:59:07.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ETS-Erlang-Term-Storage-Erlang数据存储（内存级别）"><a href="#ETS-Erlang-Term-Storage-Erlang数据存储（内存级别）" class="headerlink" title="ETS(Erlang Term Storage)Erlang数据存储（内存级别）"></a>ETS(Erlang Term Storage)Erlang数据存储（内存级别）</h2><p> <strong>ETS</strong>有四种表类型：异键(Set)、有序异键(ordered_set)、同键(bag)、副本同键(duplicate_bag)</p><ul><li>Set：键唯一</li><li>ordered_set：键唯一，元组会被排序</li><li>bag：多个元组可拥有相同的键，但不能有两个完全相同的元组（同键不同组）</li><li>duplicate_bag：多个元组可拥有相同的键，且可以有多个相同的元组（同键亦同组）</li></ul><a id="more"></a><hr><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ets:new(Name,Options)   <span class="comment">%% 返回一个表标识符，唯一标识该表</span></span><br></pre></td></tr></table></figure><ul><li>参数</li></ul><ol><li>Name：表名</li><li>Options：参数列表<br>当Options为[]时，默认参数相当于<code>[set, protected, {keypos,1}, {heir,none}, {write_concurrency,false}, {read_concurrency,false}]</code><br><br><strong>第一个选项</strong>：==set== | ==ordered_set== | ==bag== | ==duplicate_bag==<br><br><strong>第二个选项</strong>：private（唯有主管进程可读写），public（任何进程都可读写），protected（主管进程可读写，其他进程可读）<br><br><strong>named_table</strong>：如果设置此项，Name就可以被用于后续操作，相当于表标识符<br><br><strong>{keypos,K}</strong>：用K作为键的位置</li></ol><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">new</span><span class="params">(Name, Options)</span> -&gt;</span> tid() | atom()</span><br><span class="line">   Types:</span><br><span class="line">   Name = atom()</span><br><span class="line">   Options = [Option]</span><br><span class="line">   Option = </span><br><span class="line">       Type |</span><br><span class="line">       Access |</span><br><span class="line">       named_table |</span><br><span class="line">       &#123;keypos, Pos&#125; |</span><br><span class="line">       &#123;heir, Pid :: pid(), HeirData&#125; |</span><br><span class="line">       &#123;heir, none&#125; |</span><br><span class="line">       Tweaks</span><br><span class="line">   Type = type()</span><br><span class="line">   Access = access()</span><br><span class="line">   Tweaks = </span><br><span class="line">       &#123;write_concurrency, boolean()&#125; |</span><br><span class="line">       &#123;read_concurrency, boolean()&#125; |</span><br><span class="line">       compressed</span><br><span class="line">   Pos = integer() &gt;= <span class="number">1</span></span><br><span class="line">   HeirData = term()</span><br></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ets:delete(TableId)</span><br><span class="line">ets:delete(TableId,Key)</span><br></pre></td></tr></table></figure><h3 id="插入表"><a href="#插入表" class="headerlink" title="插入表"></a>插入表</h3><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ets:insert(Tab,objectOrObjects)</span><br></pre></td></tr></table></figure><h3 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h3><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ets:lookup(Tab,Key) <span class="comment">%%根据键查询</span></span><br><span class="line">ets:i(Tab) <span class="comment">%% 展示，没错，仅仅是展示所有记录</span></span><br></pre></td></tr></table></figure><h4 id="match，match-object的查询"><a href="#match，match-object的查询" class="headerlink" title="match，match_object的查询"></a>match，match_object的查询</h4><ol><li>关于match/3和match/1<a href="https://erldoc.com/mod/ets/match_1.html?search=ets:&amp;i=20" target="_blank" rel="noopener">点击了解更多match/1和match/3信息</a><br><br><strong>ets:match(Tab,Pattern,Limit)</strong>：Pattern通常为<code>&#39;$数字&#39;这样的原子类型，表示占位符（当有两个相同占位符时，表示这两个位置上的元素要相同）即要显示的结果 ，或{&#39;_&#39;,dog,&#39;$1&#39;}这样的元组，&#39;_&#39;表示通配符。Limit表示拿出几条记录，int型</code>。</li></ol><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt; Tab = ets:new(ets_tab, [named_table, bag]),ets:insert(Tab, [&#123;apple, <span class="number">1</span>&#125;, &#123;pear, <span class="number">2</span>&#125;, &#123;orange, <span class="number">3</span>&#125;, &#123;grape, <span class="number">4</span>&#125;, &#123;watermelon, <span class="number">5</span>&#125;,&#123;apple,<span class="number">6</span>&#125;]). <span class="comment">%% 创建表，并向表里插入数据</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">2</span>&gt; &#123;M1, C1&#125; = ets:match(ets_tab, &#123;apple,'$<span class="number">1</span>'&#125;, <span class="number">2</span>). <span class="comment">%%匹配表里第一个元素为apple，</span></span><br><span class="line">                                                  <span class="comment">%%第二个占位表示将表里每条记录的第二个元素存到M1里面，以如下形式</span></span><br><span class="line">                                                  <span class="comment">%% '$end_of_table'表示以这种匹配条件，没有更多的数据在表里</span></span><br><span class="line">&#123;[[<span class="number">1</span>],[<span class="number">6</span>]],'$end_of_table'&#125;                                 </span><br><span class="line"><span class="number">3</span>&gt; &#123;M2, C2&#125; = ets:match(ets_tab, &#123;'_','$<span class="number">1</span>'&#125;, <span class="number">2</span>). <span class="comment">%% 表示第一位通配，第二位占位  </span></span><br><span class="line">&#123;[[<span class="number">3</span>],[<span class="number">2</span>]],&#123;ets_tab,<span class="number">22</span>,<span class="number">2</span>,&lt;&lt;&gt;&gt;,[],<span class="number">0</span>&#125;&#125;</span><br><span class="line"><span class="number">4</span>&gt; &#123;M3, C3&#125; = ets:match(C2). <span class="comment">%% 调用 match/1 继续匹配C2                    </span></span><br><span class="line">&#123;[[<span class="number">1</span>],[<span class="number">6</span>]],&#123;ets_tab,<span class="number">101</span>,<span class="number">2</span>,&lt;&lt;&gt;&gt;,[],<span class="number">0</span>&#125;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>类似的还有ets:match_object/3和ets:match_object/1。</li><li>关于ets:match/2和ets:match_object/2，参数都为Tab和Pattern<br><br><strong>个人理解</strong>：match系列方法中，当做了“筛选条件”的位置的元素，便不会输出。因此，当需要获得符合条件的记录的全部元素时，建议使用其他方法，比如<strong>match_object</strong>。</li><li><strong>match与match_object的区别</strong>：match_object会返回符合匹配条件的记录的所有元素，因此占位符<code>&#39;$数字&#39;</code>与<code>&#39;_&#39;</code>区别不大，另外match里匹配到的记录都为列表，match_object匹配到的每条记录都是元组。</li></ol><h4 id="select-的查询"><a href="#select-的查询" class="headerlink" title="select 的查询"></a>select 的查询</h4><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt; Tab = ets:new(ets_tab, [named_table, bag]),ets:insert(Tab, [&#123;apple, <span class="number">1</span>&#125;, &#123;pear, <span class="number">2</span>&#125;, &#123;orange, <span class="number">3</span>&#125;, &#123;grape, <span class="number">4</span>&#125;, &#123;watermelon, <span class="number">5</span>&#125;,&#123;apple,<span class="number">6</span>&#125;]).</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">2</span>&gt; ets:select(ets_tab,[&#123;&#123;'$<span class="number">1</span>','$<span class="number">2</span>'&#125;,[&#123;'=:=','$<span class="number">1</span>',apple&#125;,&#123;'&lt;','$<span class="number">2</span>',<span class="number">6</span>&#125;],['$$']&#125;]).                          </span><br><span class="line">[[apple,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><ol><li>select/2第一个参数为Tab，第二个参数是一个列表或者是ets:fun2ms/1的返回值（其实该返回值也是列表），列表里面是一个固定格式的三个元素的元组。这个固定格式的三元组为</li></ol><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;第一个元素是一个元组，每个占位符对应记录的每一个元素&#125;，[第二个元素是一个关卡列表，里面包含多个用三元组描述的关卡表达式]，[第三个元素是实际返回值得描述列表]&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>第二个参数关卡示例：</li></ol><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;is_integer, '$<span class="number">1</span>'&#125;, &#123;is_integer, '$<span class="number">2</span>'&#125;, &#123;'&lt;', &#123;'+', '$<span class="number">1</span>', '$<span class="number">2</span>'&#125;, <span class="number">4711</span>&#125;]</span><br></pre></td></tr></table></figure><ol start="3"><li>第三个参数返回列表描述示例：</li></ol><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">['$$']和['$_']表示返回所有元素</span><br><span class="line">['$<span class="number">1</span>']表示仅返回'$<span class="number">1</span>'占位的元素</span><br><span class="line">['$<span class="number">1</span>','$<span class="number">2</span>']表示返回'$<span class="number">2</span>'占位的元素,伪函数表示为：ets:fun2ms(<span class="keyword">fun</span>(&#123;M, N&#125;) <span class="keyword">when</span> N &gt; <span class="number">3</span> -&gt; N,M <span class="keyword">end</span>). 所以只会返回后面的一个</span><br></pre></td></tr></table></figure><ol start="4"><li>ets:fun2ms/1作用是把语法函数转换为匹配规范的伪函数，使用前要引入<code>-include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).</code>，因为匹配规范解析转换是在 ms_transform 模块里实现，具体细节请点击<a href="https://erldoc.com/mod/ets/fun2ms_1.html?search=ets:&amp;i=8" target="_blank" rel="noopener">ets:fun2ms/1的使用</a></li><li>select/1和select/3参考ets:match系列函数</li></ol><blockquote><p><a href="https://erldoc.com/mod/ets/to_dets_2.html?search=ets:&amp;i=45" target="_blank" rel="noopener">ETS手册</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ETS-Erlang-Term-Storage-Erlang数据存储（内存级别）&quot;&gt;&lt;a href=&quot;#ETS-Erlang-Term-Storage-Erlang数据存储（内存级别）&quot; class=&quot;headerlink&quot; title=&quot;ETS(Erlang Term Storage)Erlang数据存储（内存级别）&quot;&gt;&lt;/a&gt;ETS(Erlang Term Storage)Erlang数据存储（内存级别）&lt;/h2&gt;&lt;p&gt; &lt;strong&gt;ETS&lt;/strong&gt;有四种表类型：异键(Set)、有序异键(ordered_set)、同键(bag)、副本同键(duplicate_bag)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set：键唯一&lt;/li&gt;
&lt;li&gt;ordered_set：键唯一，元组会被排序&lt;/li&gt;
&lt;li&gt;bag：多个元组可拥有相同的键，但不能有两个完全相同的元组（同键不同组）&lt;/li&gt;
&lt;li&gt;duplicate_bag：多个元组可拥有相同的键，且可以有多个相同的元组（同键亦同组）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://hellolife.top/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://hellolife.top/tags/Erlang/"/>
    
      <category term="ETS" scheme="http://hellolife.top/tags/ETS/"/>
    
  </entry>
  
  <entry>
    <title>Mnesia数据库</title>
    <link href="http://hellolife.top/13754dc.html"/>
    <id>http://hellolife.top/13754dc.html</id>
    <published>2018-08-06T08:49:22.139Z</published>
    <updated>2018-08-06T08:58:13.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mnesia数据库（内存，磁盘）"><a href="#Mnesia数据库（内存，磁盘）" class="headerlink" title="Mnesia数据库（内存，磁盘）"></a>Mnesia数据库（内存，磁盘）</h2><h2 id="创建-删除-数据库"><a href="#创建-删除-数据库" class="headerlink" title="创建/删除 数据库"></a>创建/删除 数据库</h2><ul><li><p>创建/删除一个本地数据库：</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mnesia:create_schema([node()]). </span><br><span class="line">mnesia:delete_schema([node()]).</span><br></pre></td></tr></table></figure></li><li><p>启动erlang时指定一个特定的数据库</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ erl -mnesia dir '<span class="string">"/home/Mnesia.company"</span>' <span class="comment">%% /home/Mnesia.company是将要保存这个数据库的目录</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><hr><h2 id="开启-关闭-数据库"><a href="#开启-关闭-数据库" class="headerlink" title="开启/关闭 数据库"></a>开启/关闭 数据库</h2><ul><li><strong>其中mnesia:wait_for_tables/2的作用</strong>：一些应用的某些表可能由于表数据很大，以至初始的适合需要一个初始等待的时间才能正常访问到该表的数据。mnesia:wait_for_tables/2 悬停等待一段时间，直到在 TabList 的所有表可以被访问，或超过等待的时间。<figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">start</span><span class="params">()</span> -&gt;</span>  mnesia:start(),mnesia:wait_for_tables([shop,cost],<span class="number">2000</span>).</span><br><span class="line"><span class="function"><span class="title">stop</span><span class="params">()</span> -&gt;</span>  mnesia:stop().</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><ul><li>create_table/2<figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% create_table（Name，TabDef） - &gt; &#123;atomic，ok&#125; | &#123;aborted，Reason&#125;</span></span><br><span class="line">mnesia:create_table(table_name,[&#123;attributes,record_info(fields,shop)&#125;])</span><br><span class="line"><span class="comment">%% 下面这个是官方示例</span></span><br><span class="line">mnesia:create_table(mnesia_table_name, [&#123;ram_copies, [node()]&#125;, &#123;disc_only_copies, nodes()&#125;, &#123;storage_properties, [&#123;ets, [compressed]&#125;, &#123;dets, [&#123;auto_save, <span class="number">5000</span>&#125;]&#125; ]&#125;]).</span><br></pre></td></tr></table></figure></li></ul><ul><li>record_info(type,record_name)：读取记录信息。type可为<code>fields</code>和<code>size</code>，分别为字段信息和长度信息。<figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-record</span><span class="params">(shop,&#123;item, quantity, cost&#125;)</span>.</span><br><span class="line"><span class="function"><span class="title">test_record_info</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    [record_info(fields,shop),record_info(size,shop)].</span><br><span class="line">调用test_record_info()输出：</span><br><span class="line"> [[item,quantity,cost],<span class="number">4</span>] <span class="comment">%% 字段三个，长度为4</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>Name:表名</li><li>TabDef:列表，列表元素为{key，value}的元组，允许的元组有：</li></ol><table><thead><tr><th>元组</th><th>默认值</th><th>可设值</th><th>说明</th></tr></thead><tbody><tr><td>{access_mode，Atom}</td><td>read_write</td><td>read_write/read_only</td><td>访问模式：读写模式，只读模式</td></tr><tr><td>{attributes，AtomList}</td><td>[key，val]</td><td></td><td>设置表的字段</td></tr><tr><td>{disc_copies，Nodelist}</td><td></td><td></td><td>NodeList是一个Erlang的节点列表，这些节点将保存表的==磁盘副本==，同时==执行这个操作的节点==上还会创建一个的表的==内存副本==。</td></tr><tr><td>{disc_only_copies，Nodelist}</td><td></td><td></td><td>NodeList是一个Erlang的节点列表，这些节点将==只==保存表的==磁盘副本==</td></tr><tr><td>{ram_copies，Nodelist}</td><td></td><td></td><td>NodeList是一个Erlang的节点列表，这些节点将保存表的==内存副本==</td></tr><tr><td>{index，Intlist}</td><td></td><td></td><td>Mnesia要构建和维护额外索引表的属性名称（原子）或记录字段的列表</td></tr><tr><td>{load_order，Integer}</td><td>0</td><td></td><td>具有最高加载顺序优先级的表在启动时首先加载。</td></tr><tr><td>{majority，Flag}</td><td></td><td>true/false</td><td>为true，非脏更新中止</td></tr><tr><td>{record_name，Name}</td><td></td><td></td><td></td></tr><tr><td>{snmp，SnmpStruct}</td><td></td><td></td><td></td></tr><tr><td>{storage_properties，[{Backend，Properties}]}</td><td></td><td></td><td></td></tr><tr><td>{type，Type}</td><td>set</td><td>set/ordered_set/bag/duplicate_bag</td><td>表类型</td></tr><tr><td>{local_content，Bool}</td><td>false</td><td>true/false</td><td></td></tr></tbody></table><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><ul><li><p>构建查询的基本代码,即QLC查询，参数是一个列表推导，所以查询时，当然可以进行条件筛选查询甚至连接查询！</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q = qlc:q([X || X &lt;- mnesia:table(Table_Name)])</span><br></pre></td></tr></table></figure></li><li><p>执行QLC查询,将查询到结果以列表形式返回</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qlc:e(Q)</span><br></pre></td></tr></table></figure></li><li><p>我们将qlc:e(Q)封装一下，在Mnesia事务内调用，使它变得“更为好用”。</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">do</span><span class="params">(Q)</span> -&gt;</span></span><br><span class="line">    F = <span class="keyword">fun</span>() -&gt; qlc:e(Q) <span class="keyword">end</span>,</span><br><span class="line">    &#123;atomic,Val&#125; = mnesia:transaction(F),</span><br><span class="line">    Val.</span><br></pre></td></tr></table></figure></li><li><p><font color="red">注意：</font>qlc:q/1的参数必须是一个字面上的列表推倒，不能是通过求值得出的。举个例子，下面的代码与示例里的代码不是等价的。</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Var = [X || X &lt;- mnesia:table(shop)],</span><br><span class="line">qlc:q(Var)</span><br></pre></td></tr></table></figure></li></ul><h2 id="添加行"><a href="#添加行" class="headerlink" title="添加行"></a>添加行</h2><ul><li>下面是添加一行的记录示例，Row是待插入的记录。也是以在Mnesia事务内调用mnesia:write/1函数。<figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_shop_item</span><span class="params">(Name, Quantity, Cost)</span> -&gt;</span></span><br><span class="line">    Row = #shop&#123;item=Name, quantity=Quantity, cost=Cost&#125;,</span><br><span class="line">    F = <span class="keyword">fun</span>() -&gt; mnesia:write(Row) <span class="keyword">end</span>,</span><br><span class="line">    mnesia:transaction(F).</span><br></pre></td></tr></table></figure></li></ul><h2 id="移除行"><a href="#移除行" class="headerlink" title="移除行"></a>移除行</h2><ul><li>要移除某一行，需要知道该行的对象ID。它由表名和主键的值构成。下面是删除一行的记录示例。仍然是以Mnesia事务内调用mnesia:delete/1函数。<figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">remove_shop_item</span><span class="params">(Item)</span> -&gt;</span></span><br><span class="line">    Oid = &#123;shop,Item&#125;,</span><br><span class="line">    F = <span class="keyword">fun</span>() -&gt; mnesia:delete(Oid) <span class="keyword">end</span>,</span><br><span class="line">    mnesia:transaction(F).</span><br></pre></td></tr></table></figure></li></ul><h2 id="Mnesia中的事务：采用悲观锁策略"><a href="#Mnesia中的事务：采用悲观锁策略" class="headerlink" title="Mnesia中的事务：采用悲观锁策略"></a>Mnesia中的事务：采用悲观锁策略</h2><ul><li><strong>悲观锁</strong>：每当Mnesia事务管理器==开始访问==一个表时，==都==会根据上下文情况尝试==锁定==记录甚至整个表。如果它发现这可能导致死锁，就会立即中止事务并撤销之前所做的改动。</li><li>乐观锁：提交更新的时候，才会对数据锁定并检测，如果发现冲突了，则让用户返回错误的信息，让用户决定如何去做。</li><li>F是一个不带参数的fun，事务的特性是：F里的读写操作要么都成功，要么都不成功。<figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">do_someting</span><span class="params">(...)</span> -&gt;</span></span><br><span class="line">    F = <span class="keyword">fun</span>() -&gt;</span><br><span class="line">        mnesia:write(Row),</span><br><span class="line">        mnesia:delete(Oid),</span><br><span class="line">        qlc:e(Q)</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">mnesia:transaction(F)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mnesia数据库（内存，磁盘）&quot;&gt;&lt;a href=&quot;#Mnesia数据库（内存，磁盘）&quot; class=&quot;headerlink&quot; title=&quot;Mnesia数据库（内存，磁盘）&quot;&gt;&lt;/a&gt;Mnesia数据库（内存，磁盘）&lt;/h2&gt;&lt;h2 id=&quot;创建-删除-数据库&quot;&gt;&lt;a href=&quot;#创建-删除-数据库&quot; class=&quot;headerlink&quot; title=&quot;创建/删除 数据库&quot;&gt;&lt;/a&gt;创建/删除 数据库&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建/删除一个本地数据库：&lt;/p&gt;
&lt;figure class=&quot;highlight erl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mnesia:create_schema([node()]). &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mnesia:delete_schema([node()]).&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动erlang时指定一个特定的数据库&lt;/p&gt;
&lt;figure class=&quot;highlight erl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ erl -mnesia dir &#39;&lt;span class=&quot;string&quot;&gt;&quot;/home/Mnesia.company&quot;&lt;/span&gt;&#39; &lt;span class=&quot;comment&quot;&gt;%% /home/Mnesia.company是将要保存这个数据库的目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://hellolife.top/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://hellolife.top/tags/Erlang/"/>
    
      <category term="Mnesia" scheme="http://hellolife.top/tags/Mnesia/"/>
    
  </entry>
  
  <entry>
    <title>Erlang基础</title>
    <link href="http://hellolife.top/3380.html"/>
    <id>http://hellolife.top/3380.html</id>
    <published>2018-08-02T01:13:28.084Z</published>
    <updated>2018-08-06T09:14:52.805Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Erlang：函数式编程，消息传递，容错，高并发。</strong><br><a id="more"></a></p><hr><h3 id="语句和注释"><a href="#语句和注释" class="headerlink" title="语句和注释"></a>语句和注释</h3><ol><li>“ . ”作为一条语句结束（参考英语句子）</li><li>“ ; ”连接的语句表示“或”，“ , ”连接的语句表示“且” (参考when关卡)</li><li>“%”来做行注释<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1&gt;</span> F = fun(A,B) when is_number(A),is_number(B) -&gt; A+B end. </span><br><span class="line"><span class="meta">#</span>Fun&lt;erl_eval.12.52032458&gt;</span><br><span class="line"><span class="meta">2&gt;</span> F(3,4).  </span><br><span class="line">7</span><br><span class="line"><span class="meta">3&gt;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ol><li><strong>number：</strong>erlang中的整数是精确到，也就是说不像其他编程语言（java）中有short，int，long的说法。</li><li><strong>浮点数：</strong>erlang在内部使用64位的<em>IEEE754-1985</em>，因此也会存在像C中的取整和精度问题。</li><li><strong>原子：</strong>原子被用来表示常量值（类似java中的枚举），<code>原子是全局性的，而且不需要宏定义或包含文件就能实现，原子以小写字母开头，后接一串字母、数字、下划线、@符号，原子还可以放在单引号&#39;&#39;内，这样定义原子的规则便没那么严格了，例如&#39;Monday&#39;、&#39;+&#39;,另外，原子的值就是原子本身。</code></li><li><strong>元组：</strong>大括号包起来，里面用逗号隔开的一种erlang数据类型，通常元组第一位用一个语义化的原子值占位。</li><li><strong>列表：</strong>被用来存放任意数据类型任意数量的数据类型，类似js中的数组。</li><li><strong>字符串：</strong>双引号包起来，严格来说，erlang中没有字符串，其本质就是列表。所以一般如果你想用真·字符串的时候，用Erlang的Binary类型，这样表示：&lt;&lt;”abc”&gt;&gt;。</li><li><strong>二进制型与位串：</strong>在二进制里使用整数时，必须属于0~255这个范围。二进制型&lt;&lt;”cat”&gt;&gt;是&lt;&lt;99,97,116&gt;&gt;的简写形式，也就是说，这个二进制型是由字符串里这些字符的ASCII编码组成的。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1&gt;</span> 1. %% 整数</span><br><span class="line">1</span><br><span class="line"><span class="meta">2&gt;</span> 1.2 . %% 浮点数</span><br><span class="line">1.2</span><br><span class="line"><span class="meta">3&gt;</span> a. %% 原子</span><br><span class="line">a</span><br><span class="line"><span class="meta">4&gt;</span> &#123;point,1,2&#125;. %% 元组</span><br><span class="line">&#123;point,1,2&#125;</span><br><span class="line"><span class="meta">5&gt;</span> [1,2,3]. %% 列表</span><br><span class="line">[1,2,3]</span><br><span class="line"><span class="meta">6&gt;</span> "1,2,3". %% 字符串</span><br><span class="line">"1,2,3"</span><br><span class="line"><span class="meta">7&gt;</span> &lt;&lt;"cat"&gt;&gt;. %% 二进制与位串</span><br><span class="line">&lt;&lt;"cat"&gt;&gt;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="变量与模式匹配"><a href="#变量与模式匹配" class="headerlink" title="变量与模式匹配"></a>变量与模式匹配</h3><p>erlang中<code>不存在赋值</code>的概念，只有<code>变量绑定值</code>，而且一次绑定不可改变，即“一次性赋值”。变量必须首字母大写。变量与值绑定用“=”表示，称为一次模式匹配操作。<br><strong>模式匹配的一些例子：</strong></p><table><thead><tr><th>模式 = 单位</th><th style="text-align:left">结果</th></tr></thead><tbody><tr><td> {X,abc} = {123,abc}</td><td style="text-align:left">成功:X=123 </td></tr><tr><td> {X,Y,Z} = {222,def,”cat”}</td><td style="text-align:left">成功：X = 222,Y = def, Z = “cat”</td></tr><tr><td> {X,Y} = {222,def,”cat”}</td><td style="text-align:left">失败：元组的形状不同</td></tr><tr><td> X = true</td><td style="text-align:left">成功：X = true</td></tr><tr><td> [H&#124;T] = [1,2,3,4,5]</td><td style="text-align:left">成功: H = 1,T = [2,3,4,5]</td></tr><tr><td> [A,B,C&#124;T] = [a,b,c,d,e,f]</td><td style="text-align:left">成功：A=a,B=b,C=c,T=[d,e,f]</td></tr></tbody></table><hr><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><ol><li>模块是Erlang的基本代码单元，模块保存在扩展名为<code>.erl</code>的文件里,而且必须先编译，才能运行模块里的代码。编译后的模块以<code>.beam</code>作为扩展名<center>待续</center></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Erlang：函数式编程，消息传递，容错，高并发。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Erlang" scheme="http://hellolife.top/categories/Erlang/"/>
    
    
      <category term="Erlang" scheme="http://hellolife.top/tags/Erlang/"/>
    
      <category term="函数式编程" scheme="http://hellolife.top/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
