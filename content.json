{"meta":{"title":"突然冷风吹","subtitle":null,"description":"竹杖芒鞋轻胜马","author":"yuangy","url":"http://hellolife.top"},"pages":[{"title":"404","date":"2018-08-01T15:44:03.000Z","updated":"2018-08-01T15:44:37.509Z","comments":true,"path":"404/index.html","permalink":"http://hellolife.top/404/index.html","excerpt":"","text":""},{"title":"","date":"2018-07-31T03:53:20.000Z","updated":"2018-08-01T04:12:46.295Z","comments":false,"path":"about/index.html","permalink":"http://hellolife.top/about/index.html","excerpt":"","text":"一个在路上的菜鸟程序员，个人QQ（1483782149），奉上一首很喜欢的词： 定风波·莫听穿林打叶声宋代：苏轼 三月七日，沙湖道中遇雨。雨具先去，同行皆狼狈，余独不觉，已而遂晴，故作此词。 莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。"},{"title":"分类","date":"2018-07-31T03:53:06.000Z","updated":"2018-08-01T02:17:35.414Z","comments":false,"path":"categories/index.html","permalink":"http://hellolife.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-07-31T03:52:55.000Z","updated":"2018-08-01T03:31:41.463Z","comments":false,"path":"tags/index.html","permalink":"http://hellolife.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mnesia数据库","slug":"Mnesia数据库","date":"2018-08-06T08:49:22.139Z","updated":"2018-08-06T08:58:13.356Z","comments":true,"path":"13754dc.html","link":"","permalink":"http://hellolife.top/13754dc.html","excerpt":"Mnesia数据库（内存，磁盘）创建/删除 数据库 创建/删除一个本地数据库： 12mnesia:create_schema([node()]). mnesia:delete_schema([node()]). 启动erlang时指定一个特定的数据库 1$ erl -mnesia dir '\"/home/Mnesia.company\"' %% /home/Mnesia.company是将要保存这个数据库的目录","text":"Mnesia数据库（内存，磁盘）创建/删除 数据库 创建/删除一个本地数据库： 12mnesia:create_schema([node()]). mnesia:delete_schema([node()]). 启动erlang时指定一个特定的数据库 1$ erl -mnesia dir '\"/home/Mnesia.company\"' %% /home/Mnesia.company是将要保存这个数据库的目录 开启/关闭 数据库 其中mnesia:wait_for_tables/2的作用：一些应用的某些表可能由于表数据很大，以至初始的适合需要一个初始等待的时间才能正常访问到该表的数据。mnesia:wait_for_tables/2 悬停等待一段时间，直到在 TabList 的所有表可以被访问，或超过等待的时间。12start() -&gt; mnesia:start(),mnesia:wait_for_tables([shop,cost],2000).stop() -&gt; mnesia:stop(). 创建表 create_table/21234%% create_table（Name，TabDef） - &gt; &#123;atomic，ok&#125; | &#123;aborted，Reason&#125;mnesia:create_table(table_name,[&#123;attributes,record_info(fields,shop)&#125;])%% 下面这个是官方示例mnesia:create_table(mnesia_table_name, [&#123;ram_copies, [node()]&#125;, &#123;disc_only_copies, nodes()&#125;, &#123;storage_properties, [&#123;ets, [compressed]&#125;, &#123;dets, [&#123;auto_save, 5000&#125;]&#125; ]&#125;]). record_info(type,record_name)：读取记录信息。type可为fields和size，分别为字段信息和长度信息。12345-record(shop,&#123;item, quantity, cost&#125;).test_record_info() -&gt; [record_info(fields,shop),record_info(size,shop)].调用test_record_info()输出： [[item,quantity,cost],4] %% 字段三个，长度为4 Name:表名 TabDef:列表，列表元素为{key，value}的元组，允许的元组有： 元组 默认值 可设值 说明 {access_mode，Atom} read_write read_write/read_only 访问模式：读写模式，只读模式 {attributes，AtomList} [key，val] 设置表的字段 {disc_copies，Nodelist} NodeList是一个Erlang的节点列表，这些节点将保存表的==磁盘副本==，同时==执行这个操作的节点==上还会创建一个的表的==内存副本==。 {disc_only_copies，Nodelist} NodeList是一个Erlang的节点列表，这些节点将==只==保存表的==磁盘副本== {ram_copies，Nodelist} NodeList是一个Erlang的节点列表，这些节点将保存表的==内存副本== {index，Intlist} Mnesia要构建和维护额外索引表的属性名称（原子）或记录字段的列表 {load_order，Integer} 0 具有最高加载顺序优先级的表在启动时首先加载。 {majority，Flag} true/false 为true，非脏更新中止 {record_name，Name} {snmp，SnmpStruct} {storage_properties，[{Backend，Properties}]} {type，Type} set set/ordered_set/bag/duplicate_bag 表类型 {local_content，Bool} false true/false 查询 构建查询的基本代码,即QLC查询，参数是一个列表推导，所以查询时，当然可以进行条件筛选查询甚至连接查询！ 1Q = qlc:q([X || X &lt;- mnesia:table(Table_Name)]) 执行QLC查询,将查询到结果以列表形式返回 1qlc:e(Q) 我们将qlc:e(Q)封装一下，在Mnesia事务内调用，使它变得“更为好用”。 1234do(Q) -&gt; F = fun() -&gt; qlc:e(Q) end, &#123;atomic,Val&#125; = mnesia:transaction(F), Val. 注意：qlc:q/1的参数必须是一个字面上的列表推倒，不能是通过求值得出的。举个例子，下面的代码与示例里的代码不是等价的。 12Var = [X || X &lt;- mnesia:table(shop)],qlc:q(Var) 添加行 下面是添加一行的记录示例，Row是待插入的记录。也是以在Mnesia事务内调用mnesia:write/1函数。1234add_shop_item(Name, Quantity, Cost) -&gt; Row = #shop&#123;item=Name, quantity=Quantity, cost=Cost&#125;, F = fun() -&gt; mnesia:write(Row) end, mnesia:transaction(F). 移除行 要移除某一行，需要知道该行的对象ID。它由表名和主键的值构成。下面是删除一行的记录示例。仍然是以Mnesia事务内调用mnesia:delete/1函数。1234remove_shop_item(Item) -&gt; Oid = &#123;shop,Item&#125;, F = fun() -&gt; mnesia:delete(Oid) end, mnesia:transaction(F). Mnesia中的事务：采用悲观锁策略 悲观锁：每当Mnesia事务管理器==开始访问==一个表时，==都==会根据上下文情况尝试==锁定==记录甚至整个表。如果它发现这可能导致死锁，就会立即中止事务并撤销之前所做的改动。 乐观锁：提交更新的时候，才会对数据锁定并检测，如果发现冲突了，则让用户返回错误的信息，让用户决定如何去做。 F是一个不带参数的fun，事务的特性是：F里的读写操作要么都成功，要么都不成功。1234567do_someting(...) -&gt; F = fun() -&gt; mnesia:write(Row), mnesia:delete(Oid), qlc:e(Q) end,mnesia:transaction(F)","categories":[{"name":"Erlang","slug":"Erlang","permalink":"http://hellolife.top/categories/Erlang/"}],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://hellolife.top/tags/Erlang/"},{"name":"Mnesia","slug":"Mnesia","permalink":"http://hellolife.top/tags/Mnesia/"}]},{"title":"Erlang基础","slug":"erlang基础","date":"2018-08-02T01:13:28.084Z","updated":"2018-08-06T08:29:47.772Z","comments":true,"path":"3380.html","link":"","permalink":"http://hellolife.top/3380.html","excerpt":"Erlang：函数式编程，消息传递，容错，高并发。","text":"Erlang：函数式编程，消息传递，容错，高并发。 语句和注释 “ . ”作为一条语句结束（参考英语句子） “ ; ”连接的语句表示“或”，“ , ”连接的语句表示“且” (参考when关卡) “%”来做行注释123451&gt; F = fun(A,B) when is_number(A),is_number(B) -&gt; A+B end. #Fun&lt;erl_eval.12.52032458&gt;2&gt; F(3,4). 73&gt; 基本类型 number：erlang中的整数是精确到，也就是说不像其他编程语言（java）中有short，int，long的说法。 浮点数：erlang在内部使用64位的IEEE754-1985，因此也会存在像C中的取整和精度问题。 原子：原子被用来表示常量值（类似java中的枚举），原子是全局性的，而且不需要宏定义或包含文件就能实现，原子以小写字母开头，后接一串字母、数字、下划线、@符号，原子还可以放在单引号&#39;&#39;内，这样定义原子的规则便没那么严格了，例如&#39;Monday&#39;、&#39;+&#39;,另外，原子的值就是原子本身。 元组：大括号包起来，里面用逗号隔开的一种erlang数据类型，通常元组第一位用一个语义化的原子值占位。 列表：被用来存放任意数据类型任意数量的数据类型，类似js中的数组。 字符串：双引号包起来，严格来说，erlang中没有字符串，其本质就是列表。所以一般如果你想用真·字符串的时候，用Erlang的Binary类型，这样表示：&lt;&lt;”abc”&gt;&gt;。 二进制型与位串：在二进制里使用整数时，必须属于0~255这个范围。二进制型&lt;&lt;”cat”&gt;&gt;是&lt;&lt;99,97,116&gt;&gt;的简写形式，也就是说，这个二进制型是由字符串里这些字符的ASCII编码组成的。12345678910111213141&gt; 1. %% 整数12&gt; 1.2 . %% 浮点数1.23&gt; a. %% 原子a4&gt; &#123;point,1,2&#125;. %% 元组&#123;point,1,2&#125;5&gt; [1,2,3]. %% 列表[1,2,3]6&gt; \"1,2,3\". %% 字符串\"1,2,3\"7&gt; &lt;&lt;\"cat\"&gt;&gt;. %% 二进制与位串&lt;&lt;\"cat\"&gt;&gt; 变量与模式匹配erlang中不存在赋值的概念，只有变量绑定值，而且一次绑定不可改变，即“一次性赋值”。变量必须首字母大写。变量与值绑定用“=”表示，称为一次模式匹配操作。模式匹配的一些例子： 模式 = 单位 结果 {X,abc} = {123,abc} 成功:X=123 {X,Y,Z} = {222,def,”cat”} 成功：X = 222,Y = def, Z = “cat” {X,Y} = {222,def,”cat”} 失败：元组的形状不同 X = true 成功：X = true [H&#124;T] = [1,2,3,4,5] 成功: H = 1,T = [2,3,4,5] [A,B,C&#124;T] = [a,b,c,d,e,f] 成功：A=a,B=b,C=c,T=[d,e,f] Modules 模块是Erlang的基本代码单元，模块保存在扩展名为.erl的文件里,而且必须先编译，才能运行模块里的代码。编译后的模块以.beam作为扩展名待续","categories":[{"name":"Erlang","slug":"Erlang","permalink":"http://hellolife.top/categories/Erlang/"}],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://hellolife.top/tags/Erlang/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://hellolife.top/tags/函数式编程/"}]}]}